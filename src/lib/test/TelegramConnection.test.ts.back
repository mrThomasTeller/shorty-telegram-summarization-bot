import TelegramBot from 'node-telegram-bot-api';
import { PrismaClient } from '@prisma/client';
import TelegramConnection from '../TelegramConnection.js';

jest.mock('node-telegram-bot-api');
jest.mock('@prisma/client');

const MockedTelegramBot = TelegramBot as jest.MockedClass<typeof TelegramBot>;
const MockedPrismaClient = PrismaClient as jest.MockedClass<typeof PrismaClient>;

describe('TelegramConnection', () => {
  let telegramConnection: TelegramConnection;
  let mockedBot: jest.Mocked<TelegramBot>;
  let mockedPrisma: jest.Mocked<PrismaClient>;

  beforeEach(() => {
    mockedBot = new MockedTelegramBot('fake-token', { polling: true });
    mockedPrisma = new MockedPrismaClient();

    telegramConnection = new TelegramConnection(mockedBot);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('sendToAllChats', () => {
    it('should send messages to all chats and return the count', async () => {
      const chats = [{ id: '1' }, { id: '2' }, { id: '3' }];

      mockedPrisma.chat.findMany.mockResolvedValue(chats);
      mockedBot.sendMessage.mockResolvedValue({});

      const result = await telegramConnection.sendToAllChats('test message');

      expect(result).toBe(chats.length);
      expect(mockedBot.sendMessage).toHaveBeenCalledTimes(chats.length);
      expect(mockedPrisma.chat.findMany).toHaveBeenCalled();
    });

    it('should handle errors and continue sending messages', async () => {
      const chats = [{ id: '1' }, { id: '2' }, { id: '3' }];

      mockedPrisma.chat.findMany.mockResolvedValue(chats);
      mockedBot.sendMessage
        .mockResolvedValueOnce({})
        .mockRejectedValueOnce(new Error('Test Error'))
        .mockResolvedValueOnce({});

      const result = await telegramConnection.sendToAllChats('test message');

      expect(result).toBe(chats.length - 1);
      expect(mockedBot.sendMessage).toHaveBeenCalledTimes(chats.length);
      expect(mockedPrisma.chat.findMany).toHaveBeenCalled();
    });
  });
});
